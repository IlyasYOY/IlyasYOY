# Куда войти? Заметка по SOLID
Относительно недавно я делал небольшую “шпору” по **ООП**.

Это должно было случиться и вот оно: *Шпора по SOLID*. 

**SOLID** — это принципы проектирования, которые помогают сделать код податливым эволюционным изменениям. 

Обычно этот акроним раскрывают в порядке того, как стоят буквы, но мне кажется, что это не лучший способ. Хотя он и удобен что зазубрить формулировки. 

> Это мое видение на эти принципы. **В IT есть проблема, что нет истин для всех**, поэтому это просто *моя интерпретация*.  

### Liskov Substitution Principle

> Логика, **работающая с баковым классом** должна быть **применима для классов наследников**.   

Этот принцип предупреждает вас от создания дополнительной связности в классах реализации. Она может сказаться на способах работы с наследниками так, что в местах, где используются ссылки н базовый класс, они будут неприменимы.

Это частенько нарушается, потому что есть негласные правила, которые не выражаются в типах или тестах. Например: 
- Методы инициализации. 
- Расчет на запуск кода в не многопоточный среде.

Если ваш класс *Б*, реализующий  интерфейс *А*, который в приложении считается потоковыми-безопасным, то у вас будут проблемы, если вы это свойство не сохраните.

## Single Responsibility Principle
Принцип *единой ответственности*. Ключевой принцип. 

> **Отдельная часть системы** должна иметь **единственную причину** для изменений.  

Хочу обратить внимание, что он звучит **не** так: 

> **Отдельная часть** системы должна иметь **одну ответственность**.    

Это определение неверное, потому что оно повторяет само определяемое. Оно не раскрывает что такое *единственная ответственность*.

**Пример**, который показывает это различие:  У вас есть система *А*, которая получает данные о пользователе из подсистемы *Б*. Подсистема *Б* не может выдержать нагрузку, которую вы оказываете на неё. Вы решили добавить кеширование.

Чтобы эта система соответствовала *SRP* нам надо отделить технические детали от бизнес деталей. Для этого код нам надо организовать примерно так: 
```java
public class AService {
 private final Cache cache;
 private final BService bSerbice;
 
 public Optional<UserData> fetchData(String userId) {
  return cache.run(bService, () -> bService.fetchData(userId))
   .map(this:transformResponse);
 }

 // ...

}
```

В данном коде мы отделили технические детали, они находятся где-то в классе `Cache`, нам все равно как они реализованы, поэтому будущие доработки, которые будут выполняться в рамках описанных интерфейсов — будут проходить безболезненно для бизнеса. 

В примере это показано, как разделение *технических задач* и *бизнес задач*, но это может совершаться и только в рамках бизнеса/техники. 

Например: 
- Интеграции с различными подрядчиками могут выполняться независимо друг от друга. 
- Могут независимо выполняться интеграции с разными *БД*. 

- - - -

 Принципы далее являются способами сделать ваш код соответствующими **SRP**. 

### Interface Segregation Principle

> Если интерфейс **можно разделить** без потери в его применимости, то это **надо сделать**.  

Этот принцип помогает сохранять интерфейсы вменяемого размера. Из-за него я сторонник кода, который проектируется от интерфейсов. Это позваляет воспринимать интерфейс отдельно от реализации и сконцентрироваться на *его ценности*, а не *сложности его реализации*. 

Это принцип очень сильно перекликается с *SRP*, я бы сказал, что он его переприменяет специфично для интерфейсов. 

### Open Closed Principle

> Ваш код должен быть **открыт для модификации**, и **закрыт для изменения**.  

*SRP* соблюсти без *OCP* почти невозможно. Сначала вы делаете свой код независимым от технических деталей, от других бизнес требований, либо связываете с теми местами, где он будет сидеть прочно. После этого вы *абстрагируете* детали, которые могут менять в различных средах (тестовая версия приложения, версия приложения для локального запуска). 

Детали могу быть разные: 
- **Настройки**. Переменные/константы, которые описывают поведение. 
- **Поведение**. Ваши бизнес правила, логика обработки, проверки. 

Вам надо выделить детали , если вы видите, что они могут измениться в будущем. 
 
**Пример** *деталей поведения*: Вы создаете библиотеку, что будет переводить *MD* файлы в *HTML*. Вы реализовали это. К вам пришел *CEO* и сказал, что они хотят делать конвертацию в *RTF*. Это значит, что вам пора задуматься о  своем будущем. Может стоит попробовать применить *посетитель*. Это вам позволит реализовать будущие *PDF*/*DOCX* форматы не меняя существующий код.  

### Dependency Inversion Principle

> Код должен **полагаться/зависеть на/от абстракции**.   

Я бы назвал это *принципом стрелочника* или *принципом буферных зон*, или *обмазыванием абстракцией*.

**Пример**: примеры кода вы можете нагуглить, я приведу пример из жизни, пусть он и не отражает название, но отражает содержание. Название хорошо отражается *UML* диаграммами. 
Вы сотрудник компании *XY*, вы хотите провести рекламную кампанию своего нового продукта *ZX-POINT*. Сейчас это модно делать в *TikTok*. Вы находите блоггера, заключаете с ним контракт.  Сотрудничество идет успешно, денег он берет немного, коммуникации прямые, все быстро. Но тут случился инцидент, ваш блогер разучился разговаривать, пока листал ленту. Вам надо возобновить поиск блоггера и настраивать мосты заново. 
Чтобы предупредить такую ситуацию бизнес обращается *не сразу к блоггерам*, а к рекламным агенствам, которые держат у себя  кучу таких. Это помогает вам отвязаться от конкретного блоггера и уменьшает риски описанного (и не только) формата. *Но!* Это накладывает дополнительные расходы на ваши рекламные кампании.

## Вместо вывода
Помните, это моя интерпретация этих принципов. Я не хочу вам пересказывать Википедию.

Спасибо за внимание, я надеюсь вам это было полезно! Как всегда, пишите мне, подписывайтесь на телеграм и так далее, буду рад вам!
