# Куда войти? Контракты
[Telegram: Contact @kydavoiti](https://t.me/kydavoiti/7)

## Мотивация
Часто возникает вопрос о том, как отдать, или принять данные: возвращаемые значения функции, параметры функции, зависимости класса, *REST API* вашего приложения. На все эти вопросы у меня есть довольно прозрачная точка зрения. Ей я и хочу поделиться в этой статье. Надеюсь это поможет вам писать более удобный и поддерживаемый код.  

## Идея
Идея состоит из нескольких слов.

> Спрашивай просто. Отвечай строго.   

На вход система должна принимать абстрактные данные. Чем больше свобода во входных данных - тем лучше. Когда вы отдаете данные, то надо быть конкретным. Чтобы пользователь из выхода вашей системы мог получить максимум информации. 

Далее приступим сразу к примерам, они покажут принцип более наглядно. Примеры будут рассматриваться в порядке роста уровня абстракции.

## Функции 
Простейший случай, что хотелось бы рассмотреть. 

*Задача*: на вход ограниченное кол-во элементов. Функция должна вернуть уникальное множество этих элементов. 

Обычное решение: 

```java
public static <T> List<T> distinct(List<T> items) { ... }
```

Решение, которое говорит больше обычного, а спрашивает меньше:

```java
public static <T> HashSet<T> distinct(Collection<T> items) { ... }
```

Рассмотрим различия подробнее: 
- Входные значения
	-  `List<T>` говорит пользователю, что кол-во элементов ограничено, но также и оно ограничивает варианты входных данных.
	- `Collection<T>` в данном случае подходит лучше, так как она соответствует требованиям задачи, но не навязывает лишнего.
- Выходные значения
	- `List<T>` говорит пользователю ,что мы вернем список, но она даже не говорит, что мы точно вернем уникальное множество элементов, чтобы это проверить - надо лезть в реализацию. Это можно немного улучшить, сделав `Set<T>`.
	- `HashSet<T>` данный класс в контракте говорит конкретные ограничения на класс. Пользователь точно знает как будет работать коллекция, что он получил. 

Возвращать в данном случае `Set<T>` я считаю лишней абстракцией. 

Пример, когда надо в сигнатуре функции указать интерфейс, как возвращаемое значение.
```java
public interface Person {
  Collection<Address> getFavouritePlaces()
}
```
В данном случае имеет смысл указать именно интерфейс, так как этот метод должен быть переопределен классами, что будут его реализовывать. Здесь функция, что мы написали уже является точкой входа для внешнего кода в другую часть кода, так называемым портом, к которому будут делаться адаптеры (см. [Пример гексагональной архитектуры на Java / OTUS. Онлайн-образование corporate blog / Habr](https://habr.com/en/company/otus/blog/492076/)) Мы можем сделать разные реализации, например: 
- Google
```java
public class GooglePerson implements Person {
	@Override
  public final ArrayList<Address> getFavouritePlaces() { 
    // Получаем места из Google Maps
  }
}
```
- Yandex
```java
public class YandexPerson implements Person {
	@Override
  public final ArrayList<Address> getFavouritePlaces() { 
    // Получаем места из Yandex.Maps
  }
}
```
Из этого следует следущий пример.

## Иерархии классов
Когда мы проектируем иерархии классов, то мы, следуя правилам *SOLID*, принцип *Dependency Inversion* (см.  [Принципы SOLID, о которых должен знать каждый разработчик | by Nikita | WebbDEV | Medium](https://medium.com/webbdev/solid-4ffc018077da)). Поэтому как зависимости обычно используются интерфейсы, что соответствует *Спрашивай просто*. А как зависимости мы предоставляем конкретные классы.
Пример: 
```java
@RequiredArgsContructor
public class IncomingMessageAggregator implements MessageAggregator {
  private final List<MessageProvider> messageProviders;

  public IncomingMessageAggregator(List<MessageProvider> messageProviders) {
    this.messageProviders = messageProviders;
  }

  @Override
  public ArrayList<Message> getMessages(String userId) {
    // Получаем сообщения...
  }
```

В примере мы зависим от интерфейсов. Тот, кто будет использовать этот класс, сможет подставить туда свои реализации. 

## Выводы
Надеюсь теперь у вас будет возникать меньше вопросов при построении вашего *API*, а также вашими классами будет будет пользоваться удобно и приятно. Если есть какие то вопросы, то пишите мне в [Telegram: Contact @Im_Ilya](https://t.me/Im_Ilya).
