# Куда войти? Kotlin. Почему нет?
[Telegram: Contact @kydavoiti](https://t.me/kydavoiti/30)

## Введение
В этой заметке содержится мое мнение по поводу использования **Kotlin** в больших командах, как замену **Java**. Чтобы быть последовательным сравнение будет производится как обсуждение преимуществ **Kotlin**, которые [есть на официальном сайте](https://kotlinlang.ru/docs/reference/comparison-to-java.html) этого языка. В конце будет мое личное мнение на этот счёт + резюме.  
Подписывайтесь, ставьте лайки: [Telegram: Contact @kydavoiti](https://t.me/kydavoiti)
Пишите в [Telegram: Contact @kydavoitichat](https://t.me/kydavoitichat), потрындим.

## Обсуждение пунктов
### Ссылки на null контролируются системой типов
Этот пункт мне нравится, но у него есть минусы.  Первый минус — это `when`  и множество способов делать одно и тоже. Документация к языку [содержит вот такие рекомендации](https://kotlinlang.ru/docs/reference/coding-conventions.html#if-versus-when):
```kotlin
when (x) {
    null -> // ...
    else -> // ...
}
``` 
Говорится, что стоит применять `if (x == null) y else z` в случаях *Guard*-выражений, а `when`, куда случаев 3 и более. Я согласен с этим. Но тогда возникает вопрос когда использовать `switch`? Мне кажется его незаслуженно забыли. Он обделен способностями для сопоставлению образцов и уже является рудиментом, а сам язык ещё только появился.  Более того, такие мелочные выборы отвлекают от написания кода. В **Java** такой выбор просто не стоит перед разработчиком. Такое количественное превосходство средств управления потоком выполнения дает разработчику повод лишний раз задумать и поспорить о том, что идиоматичней. Более того, я считаю, что `when` является не докрученным инструментом сопоставления. Было бы прозрачнее его использование, если бы он требовал полного покрытия всех возможных значений аргумента на этапе компиляции. Тогда бы это сузило объемы его применения именно для сопоставления с образцом, а не как затычка для любого ветвления. 
Также я считаю проблемой, вытекающей из системы типов с `null` + функция расширений, засилие методов: `apply/with/run/also/let`. По ним тоже [есть слова в документации](https://kotlinlang.ru/docs/reference/scope-functions.html). 
Хороший пример оттуда: 
```kotlin
fun displaySubstringPosition(input: String, sub: String) {
    input.indexOf(sub).takeIf { it >= 0 }?.let {
        println("Подстрока $sub находится в $input.")
        println("Начинается с индекса $it.")
    }
}
```
В нём `let ` помогает работать с возможностью избежать наличия в языке *assigment-expressions*. Иначе это было бы неуклюже, но неплохо:
```kotlin
fun displaySubstringPosition(input: String, sub: String) {
    val subString = input.indexOf(sub).takeIf { it >= 0 }
    if (subString != null) {
        println("Подстрока $sub находится в $input.")
        println("Начинается с индекса $it.")
    }
}
```
Но чаще такие методы для чего-то этакого:
```kotlin
fun processNonNullString(str: String) {}

fun main() {
    val str: String? = "Hello"   
    //processNonNullString(str)       // compilation error: str может быть null
    val length = str?.let {
        println("Вызов функции let() для $it")        
        processNonNullString(it)      // OK: 'it' не может быть null внутри конструкции '?.let { }'
        it.length
    }
}
```
Тут можно было это же заменить простой проверкой `if (x != null)`. Из-за такой разнообразности применений этих расширений, они просто используются везде, где только можно. Лично мне было бы проще работать, если бы всех этих расширений не было вовсе.
```kotlin
fun processNonNullString(str: String) {}

fun main() {
    val str: String? = "Hello"   
    //processNonNullString(str)       // compilation error: str может быть null
    val length = if (str != null) {
        println("Вызов функции let() для $str")        
        processNonNullString(str)      // OK: 'it' не может быть null внутри конструкции '?.let { }'
        str.length
    } else null
}
```
Также такая удобная работа с `null` позволяет разработчику делать глубокую вложенность классов, не ощущая проблем, которые появляются неявно при добавления каждого нового `?.` или `?:` оператора.

В **Java** этого нет, да. Это *отличие*, но *не недостаток*. Чтобы не было багов c *NPE* часто достаточно проверки на уровне адаптеров к интерфейсам. Из моего опыта редко разработчики встречают *NPE* при работе со своим кодом, часто  это происходит на границе областей работы двух команд/разработчиков. Поэтому достаточно просто чётких интерфейсов. Более того, часто **Kotlin** все равно не может избежать ошибок такого рода, потому что его типизация живет только в нем, поэтому ошибки, родные для *NPE* будут на границе взаимодействия через сеть с другими сервисами. 

В **Java** каждый более-менее опытный разработчик понимает, что если тип не *raw*, то он может быть `null`. Но есть отдельный хитрый тип ошибок, который редко замечают даже опытные разработчики — это *NPE* при оборачивании *raw* типов. Вот от него **Kotlin** защищает.

### Нет сырых (raw) типов
Не понимаю плюса этого пункта. Единственное отличие, это только что приведённый тип багов: *NPE* при оборачивании *raw* типов, отсутствует. Но это скорее связано с прошлым пунктом, чем с этим, потому что прошлый пункт — прямая причина настоящего. 
Мне кажется тут проблема у **JVM** , а не  у **Java**. Хочется иметь возможность создать объект на стеке, а не в куче, чтобы *NPE* не было — просто передавать по-значению.

### Массивы в Kotlin  инвариантны
Неплохо, даже не знаю, что сказать. Теперь я буду спать спокойней, часто использую массивы, сил моих нет, каждый день спотыкаюсь о *Boxed* массивы. Тут стоит привести важный момент из-за которого вы можете просесть по производительности (раз уж вы работаете с массивами, том просесть по перфоманс можете): 
> Также в **Kotlin** есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: `ByteArray`, `ShortArray`, `IntArray` и т.д. Данные классы не наследуют класс `Array`, хотя и обладают тем же набором методов и свойств.   
Совместимости нет, но вы держитесь, лучше чем в **Java**, но несильно.

### Kotlin имеет правильные функциональные типы и поддерживает их использование вместо SAM-типов из Java  
Почему они правильные? Чем это правильнее способа, который в **Java**? В **Java** ок все, проверяются на этапе компиляции даже. Может я не понимаю чего-то, дайте мне мерило правильности 🤷‍♂️
Может стоило его назвать: 
> Kotlin имеет функциональные типы и поддерживает их использование вместо SAM-типов из Java  
Тогда бы это не было взбросом. 

###  Вариативность на месте использования  без подстановочных символов
Просто почитайте [документацию](https://kotlinlang.ru/docs/reference/generics.html#use-site-variance-type-projections). Ребята сделали большую работу, чтобы убрать целый пласт хитрых вопросов на собеседованиях (*PECS*, *type erasure*). 

### В Kotlin нет проверяемых  исключений
И **плохо**! Одни только **Go** разработчики  (о которых я слышал, может есть и другие) понимаю, что это важно — *понимать ошибки на уровне сигнатуры*. Если вы адепты функциональных типов, то зачем вообще вам исключения? Вы не даете адептам исключений использовать их на полную. 
Почему я считаю *checked-исключения* — основной и очень важной частью языка достойно отдельной заметки, не буду распыляться тут.
Упомяну тут очень классную задумку **Kotlin** с **Nothing** типом. Читайте [тут](https://kotlinlang.ru/docs/reference/exceptions.html) подробнее. Благодаря этому код становится действительно лаконичнее.

###  Лямбда-выражения +  inline-функции = производительные и контролируемые пользовательские структуры  
Лямбда-выражения я уже упомянул выше. А про *inline* можно поговорить. Вещь, которой мне действительно оне хватает в **Java** — это *reified* типы. Это просто прекрасно. Сказал это тут потому что ребята, кто писал документацию по **Kotlin**, решили это явно не упоминать в списке важных вещей.
Я понимаю, что ребята хотят сказать, что это очень эффективно — использовать *inline* функции, но **C++** разработчики [подскажут](http://www.cplusplus.com/articles/G3wTURfi/) ,что у этого и есть МИНУСЫ, без меня это сложно представить, конечно. Также я не упоминаю про `return`, который требует явно прописывать куда вернуться. Плюс можно делать говно выход из 3 вложенных `inline` функций, вместо рефакторинг для упрощения. Мы боролись с метками & `goto`, но потом решили, что это удобна 🤩. 
Мне еще интересно было бы посмотреть бенчмарки по тому, как у нас будет работать [loop unrolling](https://blogs.oracle.com/javamagazine/loop-unrolling) ,который умеет делать **JIT**, с жирными телами цикла. 
Более того, выводы вот [этой работы](https://www.diva-portal.org/smash/get/diva2:1231573/FULLTEXT01.pdf) говорят, что плохо влияет. Кто-то заметит, что там сравнивается для **Android**, а **Android** — не **JVM** , а Москва — не Россия.

Что я хочу сказать: 
> Лямбда-выражения +  inline-функции != производительные и контролируемые пользовательские структуры.  
Или: 
> Лямбда-выражения +  inline-функции = прикольно 😃  

### Функции-расширения  
Удобная штука, чтобы добавлять методы для внешних классов. Но, если задуматься, то правильнее просто сделать композицию с декорированием внешних классов нашими. 
А вот проблем они делают много! Каждый раз, когда я вижу расширение — думаю зачем он тут. Почему поведение не было инкапсулировано к данным, что используются. Я пытался придумать себе правила употребления данного типа функций — но все тщетно, если у вас есть — пишите. Сейчас мне кажется — что это порождает разваливание кода по разным местам, где его не должно быть. 
Хороший пример использования — методы-конвертеры, но есть способы и лучше. Также расширения позволяют писать крутые и расширяемые **DSL** (только для этого **Kotlin** лучше, чем **Java**).

### Null-безопасность  
Обсуждали уже, повторяетесь. Тем более это все верно, пока мы не начинаем ходить по сети. Ходим по сети в *web*-сервисах часто, если можно так сказать.

### Умные приведения  
Имеет смысл только с `when` и `sealed` классами. Иначе — это просто поощрение написание небезопасного кода. В хорошем коде не будет явных проверок типов. 
```kotlin
fun demo(x: Any) {
    if (x is String) {
        print(x.length) // x автоматически преобразовывается в String
    }
}
```
За такое на уровне приложения — ставить **Needs Work**. Это все должно решаться на уровне полиморфизма. Я видал **ТАКИЕ ПОМОЙКИ**. В них `Any` идет через весь сервис, в котором работают с ним через приведения, а дальше просто не удосуживаются типизировать ответ и получаем в **Swagger** поля типа **object**.  
Можно скинуть проблему на тупость программистов, но это не повод поощрять такой код. Такое должно быть только на уровне фреймворков. А там лучше для такого рода штук использовать *reflection*, который более гибкий и позволяет к типу относится как к полноценному объекту, чтобы строить вокруг него бизнес логику.

### Строковые шаблоны  
По всем признакам ты `format`, кроме ленивости! Под леностью я подразумеваю возможность использовать строки как шаблоны. Ваш “шаблон” — не шаблон. Это нельзя назвать строковым шаблоном, так как шаблон должен переиспользоваться, а у вас так нельзя. Правильнее это назвать: *внутрестрочная подстановка*, так как она отрабатывает единожды.
> За шаблон извени!  

### Свойства  
Это не лучше, но хоть не хуже, чем что-то в **Java**, это просто сахар. Проблема в том, что теперь разработчикам надо точно понимать куда  поставится аннотация, но это не критично. Удобно, больше нечего сказать.

### Первичный конструктор  
 В стандартной слоистой архитектуре приложений **Java** и так один конструктор 🤔. Единственная проблема, это что **JetBrains** [не могут интегрировать расширение Spring и Lombok](https://youtrack.jetbrains.com/issue/IDEA-175127) для указания точек внедрения, а в **Kotlin** — это есть. Ждём!

### Делегирование на уровне языка
Неплохо, но есть [Lombok](https://projectlombok.org/features/experimental/Delegate).

### Выведение типа для переменных и свойств
Что-то уже есть в [Java](https://www.codejava.net/java-core/the-java-language/var-keyword-in-java) и [Lombok](https://projectlombok.org/features/experimental/var). 
Я не считаю это плюсом. Сложно проводить ревью без подсветки выведенных типов, поэтому я благодарен явному указанию типов. А по-моему удобство ревью — важнее удобства написания кода. Код — пишется один раз и одним человеком, а читается многими. Надо работать на читаемость, а не простоту в написании. 

### Синглтоны на уровне языка
Сделали потому то можете? Я не знаю зачем они, но пусть будут 🤷‍♂️. Я объявляю одиночек на уровне **Spring**, мне окей.

### Вариативность на уровне объявления и Проекции типов
> Обсуждалось выше   

### Интервалы 
Очень полезно: 
```kotlin
for (i in 1..4) print(i)
```
Я же не могу сделать: 
```java
IntStream.range(1, 5).forEach(System.out::println);
```
Еще раз  говорю: очень полезно.

### Перегрузка операторов 
Очень мощный инструмент. А когда его использовать? 
Такие вещи, как перегрузки операторов не должны быть в языке. Их область применения **невероятно** ограничена. Они применимы в различных типах, которые представляют собой что-то аддитивное (+), мультипликативное (*) и так далее. Надо предоставить строгий контракт для операторов, а не давать возможность делать с ними что угодно. Если вы не придумали как навязать свойства на операторы — не делайте их перегрузку, получится плохо: `val fiends = alice + bob` . (Да, я осмелился подружить Боба и Алису, только тссс)

### Вспомогательные объекты
Очень бесполезно 😥

### Классы данных 
Скажи [Lombok](https://projectlombok.org/features/Data) — **ДА**! (ТАААА)

### Раздельные интерфейсы для изменяемых и неизменяемых коллекций
Мне нравится, грамотно сделали, просто соглашусь, что полезно.

### Сопрограммы (корутины)
Это то, ради чего стоит использовать **Kotlin**. Пока у нас нет [Project Loom](https://openjdk.java.net/projects/loom/) — это way to go без аналогов для **Java**. Могу только хвалить ,что это умудрились сделать — спасибо! 🙏 

## Перечень пунктов из документации + выводы
### Некоторые проблемы Java, решённые в Kotlin
**Kotlin** решает целый ряд проблем, от которых страдает **Java**:
* Ссылки на **null**  [контролируются системой типов](https://kotlinlang.ru/docs/reference/null-safety.html) . (сахар)
*  [Нет сырых (raw) типов](https://kotlinlang.ru/docs/reference/java-interop.html)  (сахар)
* Массивы в Kotlin  [инвариантны](https://kotlinlang.ru/docs/reference/basic-types.html#arrays)  (сахар)
* Kotlin имеет правильные  [функциональные типы](https://kotlinlang.ru/docs/reference/lambdas.html#function-types)  и поддерживает их использование вместо SAM-типов из Java (сахар)
*  [Вариативность на месте использования](https://kotlinlang.ru/docs/reference/generics.html#use-site-variance-type-projections)  без подстановочных символов (или масок, ориг.: *wildcards*) (сахар)
* В Kotlin нет проверяемых  [исключений](https://kotlinlang.ru/docs/reference/exceptions.html)  (недостаток)

### Что есть в Kotlin, но нет в Java
*  [Лямбда-выражения](https://kotlinlang.ru/docs/reference/lambdas.html)  +  [inline-функции](https://kotlinlang.ru/docs/reference/inline-functions.html)  = производительные и контролируемые пользовательские структуры (спорный сахар)
*  [Функции-расширения](https://kotlinlang.ru/docs/reference/extensions.html) (спорный сахар)
*  [Null-безопасность](https://kotlinlang.ru/docs/reference/null-safety.html)  (сахар)
*  [Умные приведения](https://kotlinlang.ru/docs/reference/typecasts.html)  (спорный сахар)
*  [Строковые шаблоны](https://kotlinlang.ru/docs/reference/basic-types.html#strings)  (сахар)
*  [Свойства](https://kotlinlang.ru/docs/reference/properties.html)  (сахар)
*  [Первичный конструктор](https://kotlinlang.ru/docs/reference/classes.html)  (сахар)
*  [Делегирование на уровне языка](https://kotlinlang.ru/docs/reference/delegation.html) (сахар)
*  [Выведение типа для переменных и свойств](https://kotlinlang.ru/docs/reference/basic-types.html)  (сахар)
*  [Синглтоны на уровне языка](https://kotlinlang.ru/docs/reference/object-declarations.html) (спорный сахар)
*  [Вариативность на уровне объявления и Проекции типов](https://kotlinlang.ru/docs/reference/generics.html)  (полезно)
*  [Интервалы](https://kotlinlang.ru/docs/reference/ranges.html)  (сахар)
*  [Перегрузка операторов](https://kotlinlang.ru/docs/reference/operator-overloading.html) (спорный сахар)
*  [Вспомогательные объекты](https://kotlinlang.ru/docs/reference/classes.html#companion-objects)  (спорный сахар)
*  [Классы данных](https://kotlinlang.ru/docs/reference/data-classes.html)  (сахар)
*  [Раздельные интерфейсы для изменяемых и неизменяемых коллекций](https://kotlinlang.ru/docs/reference/collections.html) (плюс)
*  [Сопрограммы (корутины)](https://kotlinlang.ru/docs/reference/coroutines.html)  (плюс)

### Вывод
В **Kotlin** сплошной сахар. Есть одна причина по которой можно взяться за него: **корутины**. Если у вас аллергия на **Reactor**, то это ваш единственный способ **качественно** улучшить вашу разработку. Остальные пункты либо вредны, либо просто сахар. Сахар — это плохо, он количественно увеличивает язык, сравнивая с **Java**. Если вы берете **Kotlin** ради чего-то, а не **корутин**, то вы, скорее всего делаете большую ошибку. Количественное усложнение будет подстегивать слабых разработчиков писать плохой код. Принципиальные разработчики, чаще просто будут игнорировать переход, так как им сложно будет выработать хороше практики и спорить на ревью. Язык должен быть минималистичным, мы не занимаемся художествами, мы пишем код для бизнеса. Вместо выбора способа сделать что-то — я предпочитаю делать это.

Мой отец говорит: 
> Не ешь сладкое — жопа слипнется.  
Я поел — жопа слиплась и знатно порвало от переизбытка говна.

> **PS**. Опережая замечание, что говно-разработчики пишут говно. Я так не думаю, они отражают среду в которой они находятся. Неопределённость языка в том, чем он хочет быть и что хочет делать — играет злую шутку.  
