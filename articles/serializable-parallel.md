# Куда Войти? Serialisable Parallelization
[Telegram: Contact @kydavoiti](https://t.me/kydavoiti/20)

Привет! Обычно я рассказывают про что-то, но в этот раз я просто хочу обсудить один вопрос, который даст пищу для размышления. Здесь будет обсуждаться то, как правильно относиться к параллельному программированию, действительно ли параллельное программирование параллельно.

Для начала обсуждения надо вводятся определения: 
- **Критические секции** — это области в которых потоки производят коммуникацию для обмена сообщением или синхронизации данных.
- **Параллельное выполнение** — это работа программы в разных потоках, для вычисления результата. Потоки не имеют критических секций в процессе выполнения, кроме своего конца и начала.

## Пример из жизни
Начать хочется с жизненного примера, который проиллюстрирует проблему, которая здесь будет рассмотрена. 

Я хозяин магазина. У меня есть поставки товара, которые мне надо разгружать. На меня работают 2 группы работников.

Один из работников группы выполняет работу так: 
- Подходит к машине
- Ждет пока кто-то возьмет коробку, на 2 людей в машине нет места
- Берет коробку
- Идет с коробкой в кладовку
- Ждет там, если там уже есть другой работник
- Кладет коробку
- Далее по циклу, пока работа не будет выполнена 

Данный процесс можно назвать параллельным, он соответсвует моему определению параллельности, все они работают  без пересечений. Выполняют работу, а когда работа должна завершиться или начаться могут быть ожидания. 

Но не все группы работников начнут делать работу таким способом.

Некоторые работники начнут производить работу немного иначе:
- Работники делят работу на части
- Каждый работник отвечает только за одну часть пути
- Далее работники начинают проводить товары по цепочке

Цикл работы совпадет с циклом в прошлом случае, только он короче в смысле размера, так как он разбит на всех равномерно.

Можно поставить такой эксперимент дома и попробовать работать по двум способам. Оба они дают лучшие результаты, чем просто последовательное выполнение одним исполнителем.

Задача на подумать такая: найти аналогии второму способу выполнения в *IT*. Под *IT* подразумевается не процессы компании, а скорее *Computer Science*. Мне эта задача показалось интересной на подумать. Подумайте сначала сами, потом читайте дальше, если интересно подумать, конечно.

## Мой ответ
Я вижу отражение данного способа выполнения в [Fork Join Pool](https://www.baeldung.com/java-fork-join). Почему? Рассмотрим этапы работы *Fork Join Pool*

### Fork
Этап *Fork*, ветвление. Данный этап отвечает за то, чтобы разбить задачу на подзадачи, если проводить параллели с примером, то это  *Работники делят работу на части*. Идиоматичным примером является любой алгоритм, который решается принципом [разделяй и властвуй](https://webdevblog.ru/zhadnye-algoritmy-chast-2-razdelyaj-i-vlastvuj/). Например сортировка слиянием. Работа делится на части, работники начинают над ней работать.

### Join
Этап *Join*, объединение. В этом этапе происходит объединение частичных результатов работы. В нашем примере этот пункт является вырожденным, он явно не отображается ни на один из этапов работы работников.

### Самый главный пункт
Самый главный пункт, который позволяет этому процессу быть более эффективным, чем простое параллельное выполнение — это динамическое управление нагрузкой, которое свойственно *Fork Join Pool*, оно называется [Work Stealing](https://en.wikipedia.org/wiki/Work_stealing). Это позволяет перераспределить нагрузку с узких мест, слабых работников, кто сделал свою работу идут помогать им. Также в нем используется принцип [вытягивания](http://leanbase.ru/knowledgebase/vytyagivanie-princip-vytyagivaniya/). Работники не делают больше работы, чем могут, то есть слабые работники тоже могут быть полезными, даже если им попадется тяжелый ящик, они будут тащить его недолго, а не весь путь.

## Вывод
Надеюсь было интересно, как вам мои мысли? Если есть что обсудить — пишите мне в [Telegram: Contact @kydavoitichat](https://t.me/kydavoitichat) . И читайте мой канал [Telegram: Contact @kydavoiti](https://t.me/kydavoiti).
![](serializable-parallel/url.jpg)
